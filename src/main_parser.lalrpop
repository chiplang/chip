use std::str::FromStr;
use crate::ast::{ExprList, Expr, Number, FunctionCall, ArgList, IdentList, Ident, Opcode};
use crate::MainError;
use lalrpop_util::{ErrorRecovery, ParseError};

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, MainError>>);

extern {
    type Error = MainError;
}

// NOTE: This has trailing comma
CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub ExprList: ExprList<'input> =
    CommaSeparatedList<Expr> => ExprList(<>);

pub Expr: Box<Expr<'input>> = {
    <l:IdentList> "=" <r:RightAssign> => Box::new(Expr::Assign(l, r)),
    <RightAssign>,
};

RightAssign: Box<Expr<'input>> = {
    RightAssign ExprOp Factor => Box::new(Expr::Op(<>)),
    FunctionCall => Box::new(Expr::FunctionCall(<>)),
    Factor,
    "if" <cond:RightAssign> "{" <if_block:ExprList> "}" "else" "{" <else_block:ExprList> "}"
        => Box::new(Expr::IfElse(cond, if_block, else_block)),
    "if" <cond:RightAssign> "{" <block:ExprList> "}"
        => Box::new(Expr::If(cond, block)),
    Ident => Box::new(Expr::Ident(<>)),
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr<'input>> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Term: Box<Expr<'input>> = {
    Num => Box::new(Expr::Number(<>)),
    "(" <Expr> ")",
    ! => { errors.push(<>); Box::new(Expr::Error) },
};

// TODO: Implement underscores inbetween digits
Num: Number = {
    // Standard int with - or + at the start
    r"(\+|\-)?[0-9]+" =>? i64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| Number::Int(raw)),
    // Hexadecimal int without unary + or -
    r"0x([0-9a-fA-F])+" =>? i64::from_str_radix(&<>[2..], 16)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| Number::Int(raw)),
    // Hexadecimal int with unary + or -
    r"(\+|\-)0x([0-9a-fA-F])+" =>?i64::from_str_radix(&<>[3..], 16)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| if <>.starts_with('-') { Number::Int(-raw) }
            else { Number::Int(raw) }),
    // Standard float with optional exponent and + or - at the start
    r"(\+|\-)?[0-9]+\.[0-9]+((e|E)[0-9]+)?" =>? f64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| Number::Float(raw)),
    // Float with no dot but exponent
    r"(\+|\-)?[0-9]+(e|E)[0-9]+" =>? f64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| Number::Float(raw)),
};

FunctionCall: FunctionCall<'input> = {
    <ident:Ident> "(" <args:ArgList> ")" => FunctionCall {
        ident,
        args
    }
}

ArgList: ArgList<'input> =
    CommaSeparatedList<Expr> => ArgList(<>);

IdentList: IdentList<'input> = {
    <a:Ident> <mut v:("." <Ident>)*> => {
        v.push(a);
        IdentList(v)
    }
};

Ident: Ident<'input> =
    r"([a-zA-Z]|_)([a-zA-Z0-9]|_)*" => Ident(<>);