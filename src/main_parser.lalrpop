use std::str::FromStr;
use crate::ast::{CompilationUnit, TopLevelDef, FunctionDef, ArgDefList, ArgDef, StatementList, Statement, Number, FunctionCall, ArgList, IdentList, Ident, Opcode};
use crate::MainError;
use lalrpop_util::{ErrorRecovery, ParseError};

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, MainError>>);

extern {
    type Error = MainError;
}

pub CompilationUnit: CompilationUnit<'input> = <TopLevelDef*> => CompilationUnit(<>);

TopLevelDef: TopLevelDef<'input> = {
    "fn" <FunctionDef> => TopLevelDef::Func(<>)
};

FunctionDef: FunctionDef<'input> = {
    <ident:Ident> "(" <args:ArgDefList> ")" "{" <block:StatementList> "}"
        => FunctionDef { ident, args, return_type: None, block },
    <ident:Ident> "(" <args:ArgDefList> ")" "->" <return_type:Ident> "{" <block:StatementList> "}"
        => FunctionDef { ident, args, return_type: Some(return_type), block }
};

ArgDefList: ArgDefList<'input> =
    CommaSeparatedList<ArgDef> => ArgDefList(<>);

ArgDef: ArgDef<'input> =
    <name:Ident> ":" <chip_type:Ident> => ArgDef { name, chip_type };

// NOTE: This has trailing comma
CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// NOTE: This has a trailing comma
SemiColonSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

StatementList: StatementList<'input> =
    SemiColonSeparatedList<Statement> => StatementList(<>);

pub Statement: Box<Statement<'input>> = {
    <l:@L> <i:IdentList> "=" <e:Expr> <r:@R> => Box::new(Statement::Assign(i, e, (l ,r))),
    <l:@L> "let" <i:Ident> <r:@R> => Box::new(Statement::Let(i, (l, r))),
    <l:@L> "let" <i:Ident> "=" <e:Expr> <r:@R> => Box::new(Statement::LetAssign(i, e, (l, r))),
    <Comp>
};


Comp: Box<Statement<'input>> = {
    <l:@L> <c:Comp> <o:CompOp> <e:Expr> <r:@R> => Box::new(Statement::Op(c, o, e, (l, r))),
    <Expr>,
};

CompOp: Opcode = {
    ">" => Opcode::Gt,
    ">=" => Opcode::Ge,
    "<" => Opcode::Lt,
    "<=" => Opcode::Le,
    "==" => Opcode::Eq,
    "!=" => Opcode::Ne,
};

Expr: Box<Statement<'input>> = {
    <l:@L> <e:Expr> <o:ExprOp> <f:Factor> <r:@R> => Box::new(Statement::Op(e, o, f, (l, r))),
    <l:@L> <f:FunctionCall> <r:@R> => Box::new(Statement::FunctionCall(f, (l, r))),
    <Factor>,
    <l:@L> "if" <e:Expr> "{" <s:StatementList> "}" "else" "{" <s2:StatementList> "}" <r:@R>
        => Box::new(Statement::IfElse(e, s, s2, (l, r))),
    <l:@L> "if" <e:Expr> "{" <s:StatementList> "}" <r:@R>
        => Box::new(Statement::If(e, s, (l, r))),
    <l:@L> <i:Ident> <r:@R> => Box::new(Statement::Ident(i, (l, r))),
    <Block>
};

Block: Box<Statement<'input>> =
    <l:@L> "{" <s:StatementList> "}" <r:@R> => Box::new(Statement::Block(s, (l, r)));

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Statement<'input>> = {
    <l:@L> <f:Factor> <o:FactorOp> <t:Term> <r:@R> => Box::new(Statement::Op(f, o, t, (l, r))),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Term: Box<Statement<'input>> = {
    <l:@L> <n:Num> <r:@R> => Box::new(Statement::Number(n, (l, r))),
    "(" <Expr> ")",
    ! => { errors.push(<>); Box::new(Statement::Error) },
};

// TODO: Implement underscores inbetween digits
Num: Number = {
    // Standard int with - or + at the start
    r"(\+|\-)?[0-9]+" =>? i64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| Number::Int(raw)),
    // Hexadecimal int without unary + or -
    r"0x([0-9a-fA-F])+" =>? i64::from_str_radix(&<>[2..], 16)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| Number::Int(raw)),
    // Hexadecimal int with unary + or -
    r"(\+|\-)0x([0-9a-fA-F])+" =>?i64::from_str_radix(&<>[3..], 16)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| if <>.starts_with('-') { Number::Int(-raw) }
            else { Number::Int(raw) }),
    // Standard float with optional exponent and + or - at the start
    r"(\+|\-)?[0-9]+\.[0-9]+((e|E)[0-9]+)?" =>? f64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| Number::Float(raw)),
    // Float with no dot but exponent
    r"(\+|\-)?[0-9]+(e|E)[0-9]+" =>? f64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: MainError::InputTooBig
        })
        .map(|raw| Number::Float(raw)),
};

FunctionCall: FunctionCall<'input> = {
    <ident:Ident> "(" <args:ArgList> ")" => FunctionCall {
        ident,
        args
    }
}

ArgList: ArgList<'input> =
    CommaSeparatedList<Statement> => ArgList(<>);

IdentList: IdentList<'input> = {
    <a:Ident> <mut v:("." <Ident>)*> => {
        v.push(a);
        IdentList(v)
    }
};

Ident: Ident<'input> =
    <l:@L> <i:r"([a-zA-Z]|_)([a-zA-Z0-9]|_)*"> <r:@R> => Ident(i, (l, r));